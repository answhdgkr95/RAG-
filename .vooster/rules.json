{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD)\n\n## 1. 총괄 요약\nRAG(Retrieval-Augmented Generation) 기반 문서 검색 시스템은 사용자가 PDF, 텍스트 등 다양한 작업 매뉴얼‧도면‧계약서를 업로드하고, 자연어 질문으로 정확한 근거와 함께 즉각적인 답변을 받을 수 있는 웹 서비스이다. ChatPDF 대비 산업 현장 맞춤형 기능(권한·OCR·태스크 Agent)을 제공하여 업무 효율과 정확성을 크게 향상시킨다.\n\n## 2. 문제 정의\n1. 현장 작업자는 방대한 매뉴얼 속 필요한 정보를 찾느라 시간을 소모한다.  \n2. 문서가 수시로 갱신되어 최신 버전 확인이 어렵다.  \n3. 잘못된 정보 전달로 안전·품질 사고 위험이 존재한다.  \n4. 기존 검색 솔루션은 키워드 위주라 맥락 이해가 부족하다.  \n\n## 3. 목표 및 목적\n- 1차 목표: 업로드 문서에서 근거 기반 Q&A 제공\n- 2차 목표: 권한·버전 관리 및 Agent 기반 고차 질문 지원\n- 성공지표  \n  - Top-3 정답 포함률 ≥ 85%  \n  - 월간 활성 사용자(MAU) 5,000명  \n  - 평균 응답 속도 ≤ 3초  \n  - 잘못된 답변 신고율 ≤ 5%\n\n## 4. 타깃 사용자\n### 주사용자\n- 건설·제조 현장 작업자, 엔지니어, 관리자  \n- 행동: 모바일/PC로 매뉴얼‧도면 열람, 즉시 Q&A 필요  \n- 니즈: 빠르고 정확한 문서 참조, 최신 버전 보장\n\n### 부사용자\n- HSE(안전)팀, 품질팀, 문서 관리자, 경영진\n\n## 5. 사용자 스토리\n- “현장 작업자로서, 부품 교체 매뉴얼을 찾지 않고도 ‘토크 값이 얼마야?’라고 질문해 즉시 답변과 근거를 얻고 싶다.”  \n- “문서 관리자로서, 문서 변경 시 변경 요약을 자동 생성하여 사용자에게 알리고 싶다.”  \n- “엔지니어로서, 도면 이미지를 올리고 ‘규격 위반사항 요약’ 같은 복합 질문을 처리하고 싶다.”  \n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 문서 업로드\n   - PDF, TXT, DOCX 지원, 최대 200MB  \n   - 업로드 시 확장자·바이러스 검사 100% 통과  \n2. 임베딩 & 벡터 DB 저장\n   - 각 문단 최대 512 tokens 단위로 임베딩  \n   - DB: Milvus / Pinecone 선택, Top-k=5  \n   - 실패 시 재시도 3회, 로그 기록  \n3. 자연어 질문 & RAG 응답\n   - OpenAI GPT-4o 또는 Llama2-70B-Chat  \n   - 근거 문장/문단 하이라이트 포함  \n   - 불확실성≥0.3일 때 “답변 불확실” 경고  \n4. 샘플 문서 탑재\n   - 초기 2개 예제(설비 매뉴얼, 안전지침) 제공  \n5. 근거 문장 출력\n   - UI에 collapse/expand 형태로 표시  \n   - 클릭 시 원본 문서 페이지로 이동\n\n### 보조 기능 (Nice-to-Have)\n1. 문서 분류  \n2. Agent 태스크(고차 질문)  \n3. 문서 요약(개요)  \n4. 도면/이미지 OCR  \n5. 권한 기반 접근(업로더 전용, Role: viewer/editor/admin)  \n6. 문서 변경 이력 및 변경점 요약  \n7. 시공 단계별 응답 분류  \n8. 일정 리마인더 생성  \n9. 오답 리포트 및 GPT 피드백\n\n## 7. 비기능 요구사항\n- 성능: 평균 응답 ≤3초, p95 ≤5초  \n- 보안: OAuth2.0, JWT, AES256 at rest, GDPR 준수  \n- 사용성: 모바일 반응형, WCAG 2.1 AA  \n- 확장성: 동시 접속 10,000명, 오토스케일링  \n- 호환성: Chrome, Edge, Safari 최신 2버전  \n- 가용성: 99.9% SLA\n\n## 8. 기술 고려사항\n- 아키텍처: React+Next.js(SSR) ‑> API Gateway ‑> Python FastAPI(Microservice) ‑> Vector DB + PostgreSQL  \n- 임베딩 모델: OpenAI text-embedding-3 / local Instructor-xl fallback  \n- Storage: AWS S3, 버전 관리 활성화  \n- 배포: Docker, Kubernetes, GitHub Actions CI/CD  \n- 모니터링: Prometheus, Grafana, Sentry  \n- 3rd-party: OCR(Tesseract/Google Vision API), Notification(Slack, Email)\n\n## 9. 성공지표 & KPI\n- MAU, 신규 가입률, 재방문률  \n- 질문당 평균 응답 시간  \n-Top-3 정확도, 오답 신고율  \n- 업로드 문서 수, 사용량(쿼리/일)  \n- 비용/쿼리 ≤ $0.002\n\n## 10. 일정 & 마일스톤\n- Phase 1 (M1~M2): 기본 업로드, 임베딩, Q&A, 샘플 문서  \n- Phase 2 (M3~M4): 권한 관리, 문서 분류, OCR, 요약  \n- Phase 3 (M5~M6): Agent 태스크, 변경 이력, 일정 리마인더, 오답 리포트  \n- Beta 출시: M4, 정식 GA: M6\n\n## 11. 위험 및 대응\n- 모델 정확도 부족 → 도메인 데이터 파인튜닝, 휴먼 리뷰  \n- 대용량 문서 처리 지연 → 배치 전처리, 캐싱  \n- 민감 정보 유출 → 데이터 마스킹, 권한 관리  \n- 사용자 채택 저조 → 현장 교육, 피드백 루프  \n- API 비용 급증 → 호출 최적화, 로컬 모델 하이브리드\n\n## 12. 향후 고려\n- 멀티언어 지원(영‧중)  \n- 온프레미스 패키지 제공  \n- 3D 도면·BIM 파일 분석  \n- AR 기기를 통한 현장 안내  \n- 지속 학습 파이프라인 구축",
      "writedAt": "2025-07-11T01:40:03.824Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 총괄 요약\n- 프로젝트 개요  \n  - RAG 기반 문서 검색 웹서비스로, 산업 현장 매뉴얼·도면·계약서에 대해 근거 포함 Q&A를 제공  \n- 핵심 기술 스택  \n  - Frontend: React + Next.js(SSR)  \n  - Backend: Python FastAPI 마이크로서비스  \n  - 저장소: PostgreSQL (메타데이터), Milvus 또는 Pinecone(벡터), AWS S3(문서)  \n- 주요 기술 목표  \n  - 평균 응답 ≤ 3 초 / p95 ≤ 5 초  \n  - 99.9 % 가용성, 동시 접속 10 000명 대응  \n  - Top-3 정답 포함률 ≥ 85 %  \n- 핵심 전제  \n  - 클라우드 우선(AWS), 컨테이너 기반(Kubernetes)  \n  - GPT-4o 우선, 로컬 Instructor-XL 백업  \n  - 예산 최적화를 위해 호출량·모델 선택을 하이브리드로 관리  \n\n## 2. 기술 스택\n\n| Category            | Technology / Library            | Reasoning (선정 이유)                               |\n| ------------------- | ------------------------------ | -------------------------------------------------- |\n| Frontend            | React + Next.js (SSR)          | SEO·초기 로딩 최적, CSR·SSR 혼합 가능              |\n| 상태 관리           | React Context + SWR            | 단순 캐싱·페칭에 충분, 외부 라이브러리 최소화      |\n| Styling             | Tailwind CSS                   | 생산성·일관된 디자인 시스템, 러닝커브 낮음         |\n| Backend Framework   | Python FastAPI                 | 비동기 지원, OpenAPI 문서 자동화, 경량 마이크로서비스|\n| Runtime             | Python 3.11                    | 성능 개선, 보안 패치 최신                          |\n| Relational DB       | PostgreSQL (AWS RDS)           | 트랜잭션 강력, JSONB 지원, 커뮤니티·관리 용이      |\n| Vector DB           | Milvus (stand-alone)           | 오픈소스, 자체 호스팅, 비용 절감, kNN 성능 우수    |\n| Object Storage      | AWS S3                         | 대용량 문서 저장, 버전 관리, 내구성 11 9's         |\n| Embedding Model     | OpenAI text-embedding-3        | 정확도·호환성 우수, 벤더 잠김 완화 위해 로컬 fallback |\n| LLM                 | OpenAI GPT-4o / Llama2-70B     | 품질-비용 균형, 하이브리드 선택                    |\n| Authentication      | OAuth2.0 + JWT                | 소셜 로그인·API 인증 통합                          |\n| Deployment          | Docker + Kubernetes (AWS EKS)  | 오토스케일·롤링업데이트, 팀 친숙                   |\n| CI/CD               | GitHub Actions                 | 클라우드 네이티브, 설정 단순                       |\n| Monitoring          | Prometheus + Grafana, Sentry   | 메트릭·로그·에러 통합 관측                         |\n| Caching             | Redis (AWS ElastiCache)        | 세션·쿼리 캐시, API 응답 지연 최소화               |\n| OCR (Phase 2)       | Tesseract + pytesseract        | 오픈소스, 기본 한글 지원, 비용 無                  |\n| Notification        | AWS SES + Slack Webhook        | 이메일·팀 알림 통합                                |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n- Frontend  \n  - Next.js SSR, Tailwind UI, OAuth2 연동  \n- API Gateway  \n  - AWS API Gateway, 인증·레이어7 라우팅  \n- RAG Service (FastAPI)  \n  - 업로드, 임베딩, 검색, LLM 프롬프트 조합  \n- Vector Store  \n  - Milvus 클러스터, Top-k 검색  \n- Metadata Store  \n  - PostgreSQL: 유저·문서·권한·로그  \n- Object Storage  \n  - S3: 원본 파일, 파싱 결과, 버전 관리  \n- Caching Layer  \n  - Redis: 단기 세션·쿼리 캐싱  \n- Monitoring Stack  \n  - Prometheus, Grafana, Sentry  \n\n### 상호작용 다이어그램\n```mermaid\ngraph TD\n    F[Next.js Frontend] -->|REST/HTTPS| G(API Gateway)\n    G -->|JWT 검증| A[FastAPI RAG Service]\n    A -->|SQLAlchemy| P[PostgreSQL]\n    A -->|gRPC| V[Milvus]\n    A -->|S3 SDK| S[S3 Bucket]\n    A -->|Redis Client| R[Redis]\n    A -->|OpenAI API| O[LLM / Embedding]\n```\n\n- 프론트엔드는 HTTPS REST로 API Gateway에 요청, JWT 포함  \n- API Gateway는 FastAPI로 라우팅, 권한·쿼터 검사  \n- FastAPI 서비스는 Milvus에서 근접 벡터 검색 후 LLM 호출  \n- 문서·메타데이터는 S3·PostgreSQL에 저장, Redis로 캐시  \n\n### 코드 조직 & 컨벤션\n도메인 기반 모듈화를 적용한다.\n\n```\n/\n├── frontend/\n│   ├── components/\n│   ├── pages/\n│   ├── hooks/\n│   └── styles/\n├── backend/\n│   ├── app/\n│   │   ├── api/           # REST 엔드포인트\n│   │   ├── domain/\n│   │   │   ├── documents/ # 업로드·파싱·버전\n│   │   │   ├── search/    # 임베딩·RAG\n│   │   │   └── users/     # 인증·권한\n│   │   ├── core/          # 설정, 로깅, 예외\n│   │   ├── services/      # 외부 API 클라이언트\n│   │   └── models/        # Pydantic 스키마\n│   └── tests/\n├── infra/\n│   ├── k8s/               # Helm 차트\n│   ├── terraform/         # AWS 리소스\n│   └── github-actions/\n└── docs/\n```\n\n### 데이터 흐름 & 통신 패턴\n- 클라이언트 ↔ 서버: JSON REST, OAuth2 Bearer JWT  \n- DB 접근: SQLAlchemy ORM, 연결 풀 관리  \n- 외부 API: 비동기 HTTPx, 재시도·타임아웃 공통 Wrapper  \n- 실시간 필요 시: SSE를 통한 업로드 진행률 전송  \n- 데이터 일관성: 단일 작성 원칙(PostgreSQL), 캐시 무효화 패턴 적용  \n\n## 4. 성능 최적화 전략\n- 임베딩·LLM 요청을 비동기 배치 처리, 큐(내장 Celery)로 슬로우 태스크 분리  \n- Redis 캐시로 빈번 질문·최근 문서 검색 결과 TTL 5분 저장  \n- Milvus IVF_FLAT + HNSW 인덱스 설정으로 벡터 검색 지연 최소화  \n- Next.js SSR 페이지를 CloudFront로 캐싱하여 초기 로딩 가속  \n\n## 5. 구현 로드맵 & 마일스톤\n\n### Phase 1: 기반(MVP) – M1~M2\n- Kubernetes 클러스터, CI/CD 파이프라인 구축  \n- 문서 업로드·임베딩·검색·RAG Q&A 핵심 기능  \n- OAuth2 소셜 로그인, JWT 발급  \n- 기본 모니터링(Grafana 대시보드)  \n- 베타 릴리스 준비  \n\n### Phase 2: 기능 확장 – M3~M4\n- 권한(Role)·문서 분류·OCR 기능 통합  \n- 변경 이력 저장 및 요약 생성  \n- 캐싱·쿼리 최적화로 p95 지연 20 % 감소  \n- 알림(이메일·Slack) 및 오답 리포트 UI 추가  \n- 베타 → GA 출시  \n\n### Phase 3: 스케일링 & 최적화 – M5~M6\n- 오토스케일 파라미터 튜닝, HPA 적용  \n- Agent 태스크(복합 질문)·일정 리마인더 기능  \n- GDPR·내부 감사 로그, 취약점 스캐닝 자동화  \n- 비용 리포트 대시보드, 티어별 모델 사용 정책  \n\n## 6. 위험 평가 및 대응 전략\n\n### 기술 리스크\n- 모델 정확도 저하 → 도메인 파인튜닝·휴먼 검증 워크플로 추가  \n- 벡터 검색 병목 → Milvus 샤딩·인덱스 파라미터 최적화  \n- S3 대용량 업로드 지연 → 멀티파트 업로드·프리사인 URL 적용  \n- 외부 LLM 장애 → 로컬 Llama2 Fallback, 캐시된 응답 활용  \n\n### 프로젝트 전달 리스크\n- 일정 지연 → 기능 우선순위 조정, 주간 버너다운 추적  \n- 인력 부족 → 외주 QA 활용, 핵심 모듈 코드 리뷰 강화  \n- 품질 저하 → 테스트 커버리지 70 % 이상, PR 템플릿 의무화  \n- 배포 실패 → Blue-Green 배포, 즉시 롤백 스크립트 준비  \n\n---",
      "writedAt": "2025-07-11T01:40:03.828Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline Document\n\n---\n\n## 1. Project Overview\n\nThis project implements a Retrieval-Augmented Generation (RAG) document search web service for industrial field manuals, drawings, and contracts. The system enables users to upload documents (PDF, TXT, DOCX), ask natural language questions, and receive evidence-based answers using advanced AI models. The architecture is built on a cloud-native, containerized stack:\n\n- **Frontend:** React with Next.js (SSR), Tailwind CSS\n- **Backend:** Python FastAPI microservices\n- **Datastores:** PostgreSQL (metadata), Milvus/Pinecone (vector), AWS S3 (documents)\n- **Authentication:** OAuth2.0 + JWT\n- **Deployment:** Docker, Kubernetes (EKS), GitHub Actions CI/CD\n- **Monitoring:** Prometheus, Grafana, Sentry\n- **Caching:** Redis\n\nKey architectural decisions include strict domain-based modularization, API-driven integration, and asynchronous processing for heavy tasks.\n\n---\n\n## 2. Core Principles\n\n1. **Single Responsibility:** Every file, function, and class MUST have a single, clear responsibility.\n2. **Explicitness:** All data flows, dependencies, and side effects MUST be explicit and discoverable.\n3. **Fail Fast & Log Clearly:** All errors MUST be handled early with actionable logging.\n4. **Security by Default:** Sensitive operations MUST enforce authentication, authorization, and data protection.\n5. **Testability:** All business logic MUST be unit-testable and covered by automated tests.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1. Frontend (React + Next.js + Tailwind CSS)\n\n#### File Organization and Directory Structure\n\n- MUST follow domain-first structure:\n  ```\n  frontend/\n    components/\n    pages/\n    hooks/\n    styles/\n  ```\n- Each component MUST reside in its own file.\n- Shared hooks and utility functions go under `hooks/` and `utils/`.\n\n#### Import/Dependency Management\n\n- MUST use absolute imports (via `jsconfig.json` or `tsconfig.json` paths).\n- MUST import only what is needed (no wildcard imports).\n- MUST keep third-party imports at the top, followed by local imports.\n\n#### Error Handling Patterns\n\n- MUST handle all async errors using `try/catch` in async functions.\n- MUST display user-friendly error messages; never expose stack traces.\n- MUST log errors to Sentry using the provided client.\n\n```javascript\n// MUST: Proper error handling in async data fetching\nimport { useState } from \"react\";\nimport * as Sentry from \"@sentry/browser\";\n\nexport async function fetchData(url) {\n  try {\n    const res = await fetch(url);\n    if (!res.ok) throw new Error(\"Failed to fetch\");\n    return await res.json();\n  } catch (error) {\n    Sentry.captureException(error);\n    throw error;\n  }\n}\n```\n\n---\n\n### 3.2. Backend (Python 3.11 + FastAPI)\n\n#### File Organization and Directory Structure\n\n- MUST follow:\n  ```\n  backend/app/\n    api/\n    domain/\n      documents/\n      search/\n      users/\n    core/\n    services/\n    models/\n  ```\n- Each domain submodule MUST encapsulate its logic and data models.\n\n#### Import/Dependency Management\n\n- MUST use absolute imports within the project.\n- MUST declare all dependencies in `pyproject.toml` or `requirements.txt`.\n- MUST NOT import unused modules.\n\n#### Error Handling Patterns\n\n- MUST use FastAPI exception handlers for HTTP errors.\n- MUST log all errors with structured logs (JSON, including trace IDs).\n- MUST return standardized error responses.\n\n```python\n# MUST: Standardized error handler\nfrom fastapi import Request, HTTPException\nfrom fastapi.responses import JSONResponse\nimport logging\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException):\n    logging.error(f\"{request.url} - {exc.detail}\")\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"code\": exc.status_code},\n    )\n```\n\n---\n\n## 4. Code Style Rules\n\n### 4.1. MUST Follow\n\n- **Consistent Naming:** Use `camelCase` for JS/TS variables/functions, `PascalCase` for React components, `snake_case` for Python.\n  - *Rationale:* Increases readability and aligns with language conventions.\n\n- **Type Safety:** Use TypeScript for all React code; use Pydantic models for FastAPI.\n  - *Rationale:* Prevents runtime errors and improves maintainability.\n\n- **Modularization:** Each module/file must encapsulate a single domain or feature.\n  - *Rationale:* Simplifies code navigation and testing.\n\n- **Explicit API Schemas:** All API endpoints must define request/response schemas.\n  - *Rationale:* Enables auto-documentation and client generation.\n\n- **Security Checks:** All endpoints must enforce JWT authentication and role-based authorization.\n  - *Rationale:* Prevents unauthorized access and data leaks.\n\n```typescript\n// MUST: Type-safe React component\ntype DocumentProps = { title: string; page: number };\n\nconst DocumentCard: React.FC<DocumentProps> = ({ title, page }) => (\n  <div>\n    <h2>{title}</h2>\n    <span>Page: {page}</span>\n  </div>\n);\n```\n\n```python\n# MUST: Pydantic schema for FastAPI endpoint\nfrom pydantic import BaseModel\n\nclass DocumentUploadRequest(BaseModel):\n    filename: str\n    size: int\n    content_type: str\n```\n\n### 4.2. MUST NOT Do\n\n- **No God Objects:** MUST NOT create files or classes with multiple, unrelated responsibilities.\n- **No Inline SQL:** MUST NOT use raw SQL queries; always use SQLAlchemy ORM.\n- **No Silent Failures:** MUST NOT swallow exceptions without logging and user feedback.\n- **No Hardcoded Secrets:** MUST NOT embed secrets or credentials in code; use environment variables or secret managers.\n- **No Direct State Mutation in React:** MUST NOT mutate state directly; always use state setters.\n\n```javascript\n// MUST NOT: Direct state mutation in React\nstate.value = 5; // Wrong\n\n// MUST: Use setter\nsetState({ ...state, value: 5 }); // Correct\n```\n\n```python\n# MUST NOT: Multiple responsibilities in one class\nclass DocumentManager:\n    def upload(self): ...\n    def parse(self): ...\n    def search(self): ...\n    def authorize(self): ...\n# Split into separate domain modules instead.\n```\n\n---\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure\n\n- MUST organize code by domain (`documents`, `search`, `users`) both in frontend and backend.\n- Shared logic (e.g., authentication, logging) goes in `core/` or `hooks/`.\n\n### 5.2. Data Flow Patterns\n\n- **Frontend:** Data fetching via SWR or React Query, using custom hooks per domain.\n- **Backend:** Use dependency injection (FastAPI `Depends`) for services and repositories.\n- All inter-service communication MUST be via REST (JSON) or gRPC (vector DB).\n\n```typescript\n// MUST: Custom hook for data fetching\nimport useSWR from 'swr';\n\nfunction useDocuments() {\n  const { data, error } = useSWR('/api/documents');\n  return { data, error };\n}\n```\n\n```python\n# MUST: Dependency injection in FastAPI\nfrom fastapi import Depends\n\ndef get_db():\n    ...\n\n@app.get(\"/documents\")\ndef list_documents(db=Depends(get_db)):\n    ...\n```\n\n### 5.3. State Management Conventions\n\n- MUST use React Context for global state (e.g., user session), but keep business logic in hooks.\n- MUST NOT use Redux or complex state libraries unless justified by scale.\n\n### 5.4. API Design Standards\n\n- MUST use RESTful conventions: nouns for resources, HTTP verbs for actions.\n- MUST version APIs (e.g., `/api/v1/`).\n- MUST provide OpenAPI docs (FastAPI auto-generated).\n- MUST validate and sanitize all input data.\n- MUST return standardized error objects.\n\n```python\n# MUST: Versioned API router\nfrom fastapi import APIRouter\n\nrouter = APIRouter(prefix=\"/api/v1/documents\")\n```\n\n---\n\n## Example Code Snippets\n\n```typescript\n// MUST: Domain-based React component organization\n// frontend/components/documents/DocumentList.tsx\nimport { useDocuments } from '../../hooks/useDocuments';\n\nexport function DocumentList() {\n  const { data, error } = useDocuments();\n  if (error) return <div>Error loading documents</div>;\n  return (\n    <ul>\n      {data?.map(doc => (\n        <li key={doc.id}>{doc.title}</li>\n      ))}\n    </ul>\n  );\n}\n// Clear separation of concerns: fetching logic in hook, rendering in component.\n```\n\n```typescript\n// MUST NOT: Mixing unrelated logic in a single component\nfunction App() {\n  // fetch documents, handle auth, render UI, manage state all here (bad)\n}\n// This is not maintainable. Split into hooks and domain components.\n```\n\n```python\n# MUST: Structured logging with trace ID\nimport logging\n\ndef log_with_trace(message, trace_id):\n    logging.info({\"message\": message, \"trace_id\": trace_id})\n```\n\n```python\n# MUST NOT: Silent exception swallowing\ntry:\n    process()\nexcept Exception:\n    pass  # Bad: No logging, no feedback\n```\n\n---\n\n## Quality Criteria\n\n- All code MUST be modular, explicit, and testable.\n- All APIs MUST be documented and validated.\n- All errors MUST be logged and traceable.\n- All sensitive operations MUST be secured by authentication and authorization.\n- Code reviews MUST enforce these guidelines as acceptance criteria.\n\n---\n\nThis document is the definitive coding standard for this project. All contributors MUST comply to ensure code quality, maintainability, and security.",
      "writedAt": "2025-07-11T01:40:03.828Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-11T01:40:03.828Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-11T01:40:03.828Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-11T01:40:03.828Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-11T01:40:03.828Z"
    }
  ]
}